import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import java.io.Console;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Base64;

public class EncryptXml {

    private static final byte[] MAGIC = "XMLENC".getBytes(StandardCharsets.US_ASCII); // 6 bytes
    private static final byte VERSION = 1;
    private static final int SALT_LEN = 16;
    private static final int IV_LEN = 12;   // GCM recommended 12 bytes
    private static final int KEY_LEN = 32;  // 256-bit
    private static final int GCM_TAG_BITS = 128;
    private static final int PBKDF2_ITERS = 200_000;

    public static void main(String[] args) throws Exception {
        if (args.length < 3) {
            System.err.println("""
                Usage:
                  Encrypt: java EncryptXml enc <input.xml> <output.enc>
                  Decrypt: java EncryptXml dec <input.enc> <output.xml>
                """);
            System.exit(2);
        }

        String mode = args[0];
        Path in = Path.of(args[1]);
        Path out = Path.of(args[2]);

        char[] password = readPassword("Enter password: ");
        try {
            if ("enc".equalsIgnoreCase(mode)) {
                encryptFile(in, out, password);
                System.out.println("Encrypted -> " + out.toAbsolutePath());
            } else if ("dec".equalsIgnoreCase(mode)) {
                decryptFile(in, out, password);
                System.out.println("Decrypted -> " + out.toAbsolutePath());
            } else {
                System.err.println("Unknown mode: " + mode);
                System.exit(2);
            }
        } finally {
            zero(password);
        }
    }

    private static void encryptFile(Path inputXml, Path outputEnc, char[] password)
            throws IOException, GeneralSecurityException {

        byte[] plain = Files.readAllBytes(inputXml);

        SecureRandom rnd = SecureRandom.getInstanceStrong();
        byte[] salt = new byte[SALT_LEN];
        rnd.nextBytes(salt);
        byte[] iv = new byte[IV_LEN];
        rnd.nextBytes(iv);

        SecretKey key = deriveKey(password, salt, PBKDF2_ITERS, KEY_LEN);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(GCM_TAG_BITS, iv));
        byte[] ct = cipher.doFinal(plain);

        // Build binary payload
        ByteBuffer buf = ByteBuffer.allocate(
                MAGIC.length + 1 + SALT_LEN + Integer.BYTES + IV_LEN + ct.length);
        buf.put(MAGIC);
        buf.put(VERSION);
        buf.put(salt);
        buf.putInt(PBKDF2_ITERS);
        buf.put(iv);
        buf.put(ct);

        // Write Base64 for portability
        String b64 = Base64.getEncoder().encodeToString(buf.array());
        Files.writeString(outputEnc, b64, StandardCharsets.US_ASCII);
    }

    private static void decryptFile(Path inputEnc, Path outputXml, char[] password)
            throws IOException, GeneralSecurityException {

        String b64 = Files.readString(inputEnc, StandardCharsets.US_ASCII).trim();
        byte[] blob = Base64.getDecoder().decode(b64);
        ByteBuffer buf = ByteBuffer.wrap(blob);

        byte[] magic = new byte[MAGIC.length];
        buf.get(magic);
        if (!java.util.Arrays.equals(magic, MAGIC)) {
            throw new GeneralSecurityException("Invalid file header (magic).");
        }

        byte ver = buf.get();
        if (ver != VERSION) {
            throw new GeneralSecurityException("Unsupported version: " + ver);
        }

        byte[] salt = new byte[SALT_LEN];
        buf.get(salt);
        int iters = buf.getInt();
        if (iters < 50_000) { // sanity check
            throw new GeneralSecurityException("Iteration count too low: " + iters);
        }

        byte[] iv = new byte[IV_LEN];
        buf.get(iv);

        byte[] ct = new byte[buf.remaining()];
        buf.get(ct);

        SecretKey key = deriveKey(password, salt, iters, KEY_LEN);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(GCM_TAG_BITS, iv));
        byte[] plain = cipher.doFinal(ct); // verifies tag

        Files.write(outputXml, plain);
    }

    private static SecretKey deriveKey(char[] password, byte[] salt, int iters, int keyLenBytes)
            throws GeneralSecurityException {
        SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(password, salt, iters, keyLenBytes * 8);
        byte[] keyBytes = skf.generateSecret(spec).getEncoded();
        return new javax.crypto.spec.SecretKeySpec(keyBytes, "AES");
    }

    private static char[] readPassword(String prompt) throws IOException {
        Console console = System.console();
        if (console != null) {
            char[] pw = console.readPassword(prompt);
            if (pw != null && pw.length > 0) return pw;
        }
        // Fallback (IDE): read from stdin (not hidden)
        System.out.print(prompt);
        byte[] in = System.in.readAllBytes();
        String s = new String(in, StandardCharsets.UTF_8).trim();
        return s.toCharArray();
    }

    private static void zero(char[] arr) {
        if (arr != null) java.util.Arrays.fill(arr, '\0');
    }
}
