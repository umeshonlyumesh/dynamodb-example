package com.example.demo.util;

import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Base64;

public class XmlCryptoUtil {

    private static final byte[] MAGIC = "XMLENC".getBytes(StandardCharsets.US_ASCII);
    private static final byte VERSION = 1;
    private static final int SALT_LEN = 16;
    private static final int IV_LEN = 12;
    private static final int KEY_LEN = 32;  // 256-bit
    private static final int GCM_TAG_BITS = 128;
    private static final int PBKDF2_ITERS = 200_000;

    // Encrypts resource file and saves encrypted file under target/
    public static void encryptFile(String resourceName, String outFile, char[] password) throws Exception {
        byte[] plain = readResource(resourceName);

        SecureRandom rnd = SecureRandom.getInstanceStrong();
        byte[] salt = new byte[SALT_LEN]; rnd.nextBytes(salt);
        byte[] iv = new byte[IV_LEN];     rnd.nextBytes(iv);

        SecretKey key = deriveKey(password, salt, PBKDF2_ITERS, KEY_LEN);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(GCM_TAG_BITS, iv));
        byte[] ct = cipher.doFinal(plain);

        ByteBuffer buf = ByteBuffer.allocate(MAGIC.length + 1 + SALT_LEN + Integer.BYTES + IV_LEN + ct.length);
        buf.put(MAGIC).put(VERSION).put(salt).putInt(PBKDF2_ITERS).put(iv).put(ct);

        // Write base64 text for portability
        String b64 = Base64.getEncoder().encodeToString(buf.array());
        Files.createDirectories(Path.of("target"));
        Files.writeString(Path.of("target", outFile), b64, StandardCharsets.US_ASCII);
    }

    // Decrypts resource file (Base64 text) and saves plain XML under target/
    public static void decryptFile(String resourceName, String outFile, char[] password) throws Exception {
        byte[] blobB64 = readResource(resourceName);
        byte[] blob = Base64.getDecoder().decode(new String(blobB64, StandardCharsets.US_ASCII).trim());

        ByteBuffer buf = ByteBuffer.wrap(blob);
        byte[] magic = new byte[MAGIC.length]; buf.get(magic);
        if (!java.util.Arrays.equals(magic, MAGIC)) throw new GeneralSecurityException("Bad header");

        byte ver = buf.get();
        if (ver != VERSION) throw new GeneralSecurityException("Unsupported version");

        byte[] salt = new byte[SALT_LEN]; buf.get(salt);
        int iters = buf.getInt();
        byte[] iv = new byte[IV_LEN]; buf.get(iv);
        byte[] ct = new byte[buf.remaining()]; buf.get(ct);

        SecretKey key = deriveKey(password, salt, iters, KEY_LEN);
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(GCM_TAG_BITS, iv));
        byte[] plain = cipher.doFinal(ct);

        Files.createDirectories(Path.of("target"));
        Files.write(Path.of("target", outFile), plain);
    }

    // --- Helpers ---
    private static byte[] readResource(String name) throws Exception {
        try (InputStream in = XmlCryptoUtil.class.getClassLoader().getResourceAsStream(name)) {
            if (in == null) throw new IllegalArgumentException("Resource not found: " + name);
            return in.readAllBytes();
        }
    }

    private static SecretKey deriveKey(char[] pw, byte[] salt, int iters, int keyLenBytes) throws GeneralSecurityException {
        SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(pw, salt, iters, keyLenBytes * 8);
        byte[] k = f.generateSecret(spec).getEncoded();
        return new javax.crypto.spec.SecretKeySpec(k, "AES");
    }
}



=================================
import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Service;

@Service
public class StartupCryptoService {

    @PostConstruct
    public void init() {
        try {
            char[] password = "StrongPass123!".toCharArray();

            // Encrypt src/main/resources/input.xml → target/input.xml.enc
            XmlCryptoUtil.encryptFile("input.xml", "input.xml.enc", password);

            // Decrypt src/main/resources/input.xml.enc → target/roundtrip.xml
            XmlCryptoUtil.decryptFile("input.xml.enc", "roundtrip.xml", password);

            System.out.println("Encryption + Decryption done. See target/ folder.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

